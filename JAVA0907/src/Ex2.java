
public class Ex2 {

	public static void main(String[] args) {
		/*
		 * 형변환(Type casting)
		 * -어떤 데이터타입을 다른 데이터타입으로 변환하는 것
		 * -기본 형변환과 참조 형변환으로 구분됨
		 * -기본(Primitive Type)형변환, 참조(Reference Type)형변환
		 * 1. 기본형변환은 기본 데이터타입 8가지 중 boolean 을 제외한 나머지 7가지 타입끼리의 형변환
		 * 		=>작은 타입에서 큰 타입으로 변환 시 자동 형변환, 큰 타입에서 작은 타입으로 변환 시 강제 형변환
		 * 		=>강제 형변환 시 반드시 형변환 연산자를 사용하여 변환될 타입을 명시해야 한다.
		 * 		=>단, 강제 형변환 후에는 오버플로우가 발생할 위험이 있음
		 * 
		 * 2. 참조형변환(레퍼런스 형변환)
		 * 	-클래스 간의 형변환(참조형 변수끼리의 형변환)
		 * -반드시 상속관계에서만 가능한 변환
		 * -자식(서브클래스)타입에서 부모(슈퍼클래스)타입으로 변환 시 자동 형변환(업캐스팅)이라고 하여,
		 * 	 부모(슈퍼클래스)타입에서 자식(서브클래스)타입으로 변환 시 강제 형변환(다운캐스팅)이라고 한다.
		 * 
		 * 1)업캐스팅(Up Casting)
		 * 		-슈퍼클래스 타입으로 서브클래스의 인스턴스를 참조하는 것
		 * 			=>서브클래스 인스턴스를 슈퍼 클래스 타입으로 변환하는 것
		 * 		-묵시적(자동)형변환이 일어남
		 * 		-참조가능한 영역이 축소됨
		 * 		  (슈퍼클래스 타입에서 선언된 변수, 메서드만 접근 가능함)
		 * 		-하나의 슈퍼 클래스 타입으로 여러 서브클래스 인스턴스의 공통된 멤버를 접근가능하도록 해준다
		 * 		-일반적인 레퍼런스 형변환을 의미
		 * 
		 *  2)다운캐스팅Down Casting)
		 *     -서브클래스 타입으로 슈퍼클래스의 인스턴스를 참조하는 것
		 *     		=>슈퍼클래스 인스턴스를 서브클래스 타입으로 변환하는 것
		 *     	-묵시적 (자동)형변환이 일어나지 않음
		 *     		=>반드시 형변환 연산자를 사용한 명시적(강제) 행변환 필수
		 *     -  참조 가능한 영역이 확대됨
		 *     		(서브클래스 타입에서 선언된 변수, 메서드에 모두 접근 가능함)
		 *     		=> 단, 실제 존재하지 않는 영역세 대한 접근 위험성이 발생함
		 *     -묵시적(사동)형변환이 일어나지 않음
		 *     		=>반드시 형변환 연산자를 사용한 명시적(강제) 형변환 필수
		 *		-명시적으로 형변환 후에도 실행 시점에서 오류 발생할 수 있음
		 *			=>따라서,. 일반적인 상황에서의 다운캐스팅은 허용되지 않음
		 *		-  이전에 이미 업캐스팅 된 인스턴스를 다시 다운캐스팅 하는 경우에만 안전하게 변환이 일어남   
		 *     <기본 문법>
		 *     서브클래스타입 변수명 = (서브클래스타입)슈퍼클래스인스턴스;
		 */

	child c = new child(); //서브클래스의 인스턴스 생성
	//서브클래스의 인스턴스 c를 통해 접근 가능한 메서드 2개
	c.childPrn(); //자신의 클래스에서 정의한 메서드
	c.parentPrn(); //상속받은 메서드
	
	//parent 타입 변수 p를 선언하여 child클래스의 인스턴스 전달
	parent p; //슈퍼클래스 타입 참조 변수 p 선언
	p = c; //서브클래스의 인스턴스 주소를 슈퍼클래스타입 변수에 전달
	//=>child 타입 => parent 타입으로 변환됨
	//업캐스팅은 자동 형변환이 가능하므로 형변환 연산자 생략 가능
	
	//parent 타입 변수 p를 통해 접근 가능한 메서드 : 1개
	p.parentPrn(); // 상속받은 메서드는 호출가능
//	p.childPrn();//서브클래스에서 정의한 메서드는 호출 불가능
	//=>업캐스팅 후에는 참조 영역에 대한 축소가 발생하므로
	//	   상속된 멤버 외의 서브클래스에서 정의한 멤버는 접근 불가능하게 됨
	// 	   즉, 서브클래스의 멤버는 보이지 않게 됨
	System.out.println("p와 c의 주소값이 같은가? " + (p==c));
	System.out.println("-----------------------------------------------------");
	
	//슈퍼클래스 타입 인스턴스 p2 생성
	parent p2 = new parent();	
	//슈퍼클래스 타입으로 접근 가능한 서드 : 1개
	p2.parentPrn();
	//서브클래스 타입 변수 선언 및 슈퍼클래스타입 인스턴스 전달
	//childx c2=p2 오류 => 다운캐스팅은 자동 형변환이 지원되지 않음
	//			>명시적강제 형변환 필요 =-
//	child c2 = (child)p2;//ㅇ서브클래스 타입을 명시하여 강제 형변환
		//=>형변환 후에도 오류방생 
//		c2.parentPrn(); // parent 인스턴스에 존재하는 메서드
//		c2.childPrn(); //parent 인스턴스에 존하지 않는 메서드
		//=childPrn() 메서드는 실제 인
		//존재하지 않는 영역에 대한 참조의 위험 때문에
		//다운캐스팅은 자동형변환이 지원되지 않으며
		//걍제 형변환을 하더라도 실행 시점에서 논리적 오류가 발생
	System.out.println("-----------------------------------------------------");
	
	//다운캐스팅이 허용되는 경우
//	child c3 = new child(); //서브클래스의 인스턴스 생성
//	parent p3 = c3; //업캐스팅
	//위의 두 문장을 하나로 결합
	parent p3 = new child(); //업캐스팅
	//슈퍼클래스(parent) 타입으로 접근 가능한 메서드 : 1개
	p3.parentPrn();//상속받은 메서드
	
	//이미 업캐스팅 된 인스턴스를 다시 다운캐스팅
//	child c3 = p3; //명시적 형변환 필요
	child c3 = (child) p3; //다운캐스팅(실행시 오류 발생하지 않음)
	
	//서브클래스 (child)타입으로 접근 가능한 메서드 : 2개
	c3.childPrn(); //상속받은 메서드
	c3.parentPrn(); //서브클래스에서 정의한 메서드
	//이전에 업캐스팅 되어 참조영역이 축소되었떤 인스턴스를
	//다시 다운캐스팅을 통해 참조영역이 확대되면
	//접근 범위에 아무런 문제가 없으므로 사용이 가능하다
	//따라서, 레퍼런스 형변환 시에는 상속 관계를 고려하여야 한다
	//알맞은 형변환 방식을 선택해서 변환해야 한다
	}

}

class parent {
	public void parentPrn() {
		System.out.println("슈퍼클래스의 parentPrn 메서드");
	}
}

class child extends parent{
	public void childPrn() {
		System.out.println("서브클래스의 childPrn 메서드");
	}
}